# 配置项
## 别名
    aliases 配置替换 @app/config/bootstrap.php中的Yii::setAlias() 方法
## 组件
    请谨慎注册太多应用组件， 应用组件就像全局变量， 使用太多可能加大测试和维护的难度。
    引导启动组件      bootstrap   启动太多的组件会降低系统性能，因为每次请求都需要重新运行启动组件
    运行时加载组件    components   第一次使用\Yii::$app->componentID时会创建应用组件实例
# 命名规则
    目录      英文大小写字母、数字、下划线
    控制器ID   应仅包含英文小写字母、数字、下划线、中横杠和正斜杠    
# 数据库迁移
    每次迭代使用一个独立目录存放migration文件
    目录名与迭代分支名保持一致
    
# 系统变量

# MVC
## 控制器
    webController extends yii\base\Controller
    consoleController extends yii\console\Controller
    控制器很精练，包含的操作代码简短； 如果你的控制器很复杂，通常意味着需要重构， 转移一些代码到其他类中。
    [*]不应处理应被模型处理的请求数据;
    [*]应避免嵌入HTML或其他展示代码，这些代码最好在 视图中处理;
    可根据请求数据调用 模型 的方法和其他服务组件;
    可访问 请求 数据;
    可使用 视图 构造响应;
    
## 模型
    模型是代表业务数据、规则和逻辑的中心地方，通常在很多地方重用，
    在一个设计良好的应用中，模型通常比 控制器代码多。
    [*]不应直接访问请求，session和其他环境数据， 这些数据应该由控制器传入到模型;
    [*]应避免嵌入HTML或其他展示代码，这些代码最好在 视图中处理;
    [*]单个模型中避免太多的 场景.
        定义可被多个 应用主体 或 模块 共享的模型基类集合。 
        这些模型类应包含通用的最小规则集合和逻辑。
        通过继承对应的模型基类来定义具体的模型类， 具体模型类包含应用主体或模块指定的规则和逻辑。
        例如：
            frontend\models\Post extends common\models\Post
            xxxFrom extends frontend\models\Post 
            backend\models\Post extends common\models\Post
            yyyFrom extends backend\models\Post
    xxxModel extends yii\base\Model 或Model 的子类
    xxxModel extends yii\db\ActiveRecord
    xxxForm extends yii\base\Model
    public function attributeLabels() {支持多语言、分场景指定标签}
    public function scenarios() {指定场景要校验的属性、以及属性是否安全(可以被块赋值)}
    public function rules() {可分场景指定校验规则，以及属性是否安全}
    public function fields() {格式化model的数据}
    public function extraFields() {}
## 视图    
    在显示之前将用户输入数据进行转码和过滤非常重要， 否则，你的应用可能会被 跨站脚本 攻击。
    
    layout 可在不同层级（控制器、模块，应用）配置， 被置为 null 或 false 表示不使用布局
    布局默认存储在@app/[ModuleDir/]views/layouts路径下,默认 layout = 'main';
    布局可以多层嵌套
        <head>  
            $this->registerMetaTag(['name' => 'title', 'content' => '页面标题']);
            $this->registerMetaTag(['name' => 'keywords', 'content' => '关键词, 关键词']);
            $this->registerMetaTag(['name' => 'description', 'content' => '页面描述']);
            
            $this->registerLinkTag([
                'title' => '链接标题',
                'rel' => 'alternate',
                'type' => '文本格式',
                'href' => '文件链接',
            ]);
            
            重复注册的标签只保留最后一个
        </head>
        <body>
        </body>
            在内容视图中定一个或多个数据块
            <?php $this->beginBlock('block1'); ?>
            ...content of block1...
            <?php $this->endBlock(); ?>
            
        <?php $this->beginContent('@app/views/layouts/base.php'); ?>
        ...child layout content here...
            在布局视图中，数据块可用的话会渲染数据块， 如果数据未定义则显示一些默认内容。
            <?php if (isset($this->blocks['block1'])): ?>
                <?= $this->blocks['block1'] ?>
            <?php else: ?>
                ... default content for block1 ...
            <?php endif; ?>
        <?php $this->endContent(); ?>
        
        <!-- 视图事件 -->
        \Yii::$app->view->on(View::EVENT_END_BODY, function () {
            echo date('Y-m-d');
        });
    
    视图负责将模型的数据展示用户想要的格式，总之，视图
    
    应主要包含展示代码，如HTML, 和简单的PHP代码来控制、格式化和渲染数据；
    不应包含执行数据查询代码，这种代码放在模型中；
    应避免直接访问请求数据，如 $_GET, $_POST，这种应在控制器中执行， 如果需要请求数据，应由控制器推送到视图。
    可读取模型属性，但不应修改它们。
    为使模型更易于维护，避免创建太复杂或包含太多冗余代码的视图， 可遵循以下方法达到这个目标：
    
    使用 布局 来展示公共代码（如，页面头部、尾部）；
    将复杂的视图分成几个小视图，可使用上面描述的渲染方法将这些 小视图渲染并组装成大视图；
    创建并使用 小部件 作为视图的数据块；
    创建并使用助手类在视图中转换和格式化数据。 
        
        
    
# 一个请求的生命周期
    路由规则 [ModuleID/]ControllerID/ActionID
        @app\controllers\ModuleID\FirstSeccontroller 对应路由规则为 ModuleID/first-sec
        @app\controllers\subDir\FirstSeccontroller 对应路由规则为 subDir/first-sec
    controllerMap 会打破路由规则
        